---
title: "Sierra Nevada Fraction Analysis"
author: J. Beem-Miller
date: \textit{\today}
output:
  pdf_document:
    latex_engine: xelatex
    toc: yes
    toc_depth: 3
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '2'
  html_notebook:
    css: "custom.css"
    toc: yes
    toc_depth: 2
header_includes:
- \usepackage[utf8]{inputenc}
- \usepackage{float}
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      fig.align = 'center', dev = c('cairo_pdf', 'png'), fig.width = 6.5,
                      fig.height = 3.5)
options(scipen = 5)
# load page breaks fx
source("./utilities/page_break_Rmd.R")
```

```{r setup, include = FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
library(SoilR)
library(openxlsx)
library(ISRaD)
library(lme4)
library(lmerTest)
library(emmeans)
library(gt)
library(scales)
```

```{r load raw-data-ingest fx}
source("./utilities/jena_ams_ingest.R")
source("./utilities/jena_iso_ingest.R")
source("./utilities/jena_elm_ingest.R")
```

```{r plot-funs}
# color palettes for ECO & PM
warm <- "#BF812D"
cool <- "#80CDC1"
cold <- "#01665E"
granite <- "#9daba9"
andesite <- "#382dbf"
basalt <- "#bf382d"
minC <- "#9b003f"
fPOM <- "#3f9b00"
oPOM <- "#0047af"
```

# Load data
## Internal 
### CN
#### Read raw

```{r load-cn-dat}
# 2001 & 2019 density fraction data
elm_results_dir <- list.files("../data/raw", pattern = "elm_jena_results", full.names = TRUE)
elm_results_ls <- lapply(seq_along(elm_results_dir), function(i) {
  if (grepl("elm_jena_results-soil", elm_results_dir[i])) {
    template_file <- "../data/raw/elm_jena_template/elm_jena_template2.xls"
  } else {
    template_file <- "../data/raw/elm_jena_template/elm_jena_template.xls"
  }
  read_jena_elm_results(elm_results_dir[i], template_file = template_file)
})
names(elm_results_ls) <- list.files("../data/raw", pattern = "elm_jena_results")

# separate bulkC from frcC
elm_results_blkC_ls <- elm_results_ls[which(grepl("elm_jena_results-soil", names(elm_results_ls)))]
elm_results_frcC_ls <- elm_results_ls[which(grepl("elm_jena_results-frc", names(elm_results_ls)))]

# extract bulk C and summarize
sra.blk.2019.df <- bind_rows(unlist(elm_results_blkC_ls, recursive = FALSE)) %>%
  mutate(PMeco = sapply(strsplit(ID, "_"), "[", 2),
         depth = sapply(strsplit(ID, "_"), "[", 4))
sra.blk.2019.sum.df <- sra.blk.2019.df %>%
  group_by(PMeco, depth) %>%
  summarize(across(c(C, N), .fns = list(mean = mean, sd = sd)), .groups = "drop") %>%
  mutate(ID2 = paste(PMeco, depth, sep = "_"))
```

#### Templates

```{r create-frc-data-templates}
## Create template for composite soil data (e.g. density fractions)
# Basic list template
PMeco.ls <- vector(mode = "list", length = 9)
names(PMeco.ls) <- levels(interaction(c("AN", "BS", "GR"), c("pp", "wf", "rf"), sep = ""))

# list of depths for 2001 samples
depth_bot_2001.ls <- list(ANpp = c(6, 13, 33),
                          ANwf = c(11, 35),
                          ANrf = c(11, 32),
                          BSpp = c(7, 18, 28),
                          BSwf = c(10, 19),
                          BSrf = c(8, 15, 30),
                          GRpp = c(7, 15, 27),
                          GRwf = c(4, 13, 28),
                          GRrf = c(8, 27))

# list of depths for 2019 samples
depth_bot_2019.ls <- lapply(PMeco.ls, function(df) seq(10, 30, 10))

# template fx
sra.frc.template.fx <- function(depth_bot, year) {
  nms <- names(depth_bot)
  ls <- lapply(seq_along(depth_bot), function(i) {
    n <- length(depth_bot[[i]])
    df <- data.frame(year = rep(year, n),
                     PM = rep(substr(nms[i], 1, 2), n), 
                     ECO = rep(substr(nms[i], 3, 4), n),
                     lyr_bot = depth_bot[[i]])
    df$lyr_top <- sapply(seq_along(depth_bot[[i]]), function(j) {
      if (j == 1) {
        0
      } else {
        depth_bot[[i]][j - 1]
      }
    })
    df$ID <- paste0(df$PM, df$ECO, "_comp_", df$year, "_", df$lyr_top, "-", df$lyr_bot)
    return(df)
  })
  names(ls) <- nms
  frc.ls <- replicate(3, ls, FALSE)
  names(frc.ls) <- c("FPOM", "OPOM", "MOM")
  return(frc.ls)
}

# 2001
sra.frc.tmp.2001.ls <- sra.frc.template.fx(depth_bot_2001.ls, 2001)

# 2019
sra.frc.tmp.2019.ls <- sra.frc.template.fx(depth_bot_2019.ls, 2019)
```

#### Merge raw w/ template

```{r fill-frc-cn}
# define extraction function
fill.cn.fx <- function(template, elm_results_ls, year, type) {
  
  # internal fx for extracting cn data and averaging analytical duplicates as needed
  extract.elm.fx <- function(ls) {
    lapply(ls, function(x) {
      ix <- grep(x$ID, cn.df$ID)
      if (length(ix > 1)) {
        x <- cbind(x,
                   C = mean(cn.df[ix, "C"]), 
                   N = mean(cn.df[ix, "N"]), 
                   row.names = NULL)
      } else if (length(ix) == 1) {
        x <- cbind(x, cn.df[ix, c("C", "N")], row.names = NULL)
      }
      return(x)
    })    
  }
  
  # select CN data by year
  cn.ls <- unlist(
    lapply(grep(paste0(type, substr(year, 3, 4)), names(elm_results_ls)), function(i) {
      elm_results_ls[[i]]
    }), recursive = FALSE)
  
  # store fraction names
  nms <- names(template)
  
  # loop for running extraction
  for(i in seq_along(nms)) {
    
    # make data frame of data for target fraction and year
    cn.df <- bind_rows(cn.ls[grep(names(template)[i], names(cn.ls))])
    
    # check if target fraction data exist and run extraction function if so
    if (nrow(cn.df) != 0) {
      
      # extract data for each fraction
      template[[i]] <- lapply(template[[i]], function(df) {
        bind_rows(extract.elm.fx(split(df, df$ID)))
      })
    }
  }
  
  # return output list named by target fraction
  names(template) <- nms
  return(template) 
}

# extract fraction data by year
sra.frc.2001.ls <- fill.cn.fx(sra.frc.tmp.2001.ls, elm_results_frcC_ls, 2001, "frc")
sra.frc.2019.ls <- fill.cn.fx(sra.frc.tmp.2019.ls, elm_results_frcC_ls, 2019, "frc")
```

### 14C

```{r load-14c-dat}
# read ams dir
ams_jena_results_dirs <- list.files("../data/raw", pattern = "ams_jena_results", full.names = TRUE)

# list files w/ new and old templates by date
dates <- sapply(lapply(strsplit(ams_jena_results_dirs, "_(?!.*_)", perl = TRUE), "[[", 2), as.Date)
ams_jena_results_dirs_new <- ams_jena_results_dirs[which(dates > as.Date("2022-01-23"))]
ams_jena_results_dirs_old <- ams_jena_results_dirs[which(dates < as.Date("2022-01-23"))]

# new template
new_template <- "../data/raw/ams_jena_template_2022-01-24/ams_jena_template.xlsx"

# read in data
ams_results_ls <- c(
  lapply(seq_along(ams_jena_results_dirs_new), function(i) {
    read_jena_ams_results(ams_jena_results_dirs_new[i], 
                          template_file = new_template,
                          start = 31)
  }),
  lapply(seq_along(ams_jena_results_dirs_old), function(i) {
    read_jena_ams_results(ams_jena_results_dirs_old[i])
  }))
names(ams_results_ls) <- unlist(
  c(lapply(strsplit(ams_jena_results_dirs_new, "/(?!.*/)", perl = TRUE), "[[", 2),
    lapply(strsplit(ams_jena_results_dirs_old, "/(?!.*/)", perl = TRUE), "[[", 2)))
```

### Mass

```{r load-frc-mass-data}
# load raw data
sra.frc.mss.raw <- read_excel("../data/raw/lab_jena_results-frc19-frc01_2021-05-05/Dichtefraktionierung_Jeff_2020.xls", sheet = "Tabelle1")

# filter and reduce
sra.frc.mss.df <- sra.frc.mss.raw %>%
  filter(is.na(SampleRedone)) %>%
  select(Probe, `Einwaage (g)`, Fraktion, `LF (g)`, `HF (g)`) %>%
  mutate(yield = ifelse(is.na(`LF (g)`), `HF (g)`, `LF (g)`)) %>%
  select(-c(`LF (g)`, `HF (g)`)) %>%
  rename(wt_g = `Einwaage (g)`)

# 1) combine multiple flask samples for individual flasks
# 2) fill in missing oPOM data from 2019 GRrf sites
# NB: almost no loss for 2001 sites, so seems justified to assume none in 2019
sra.frc.mss.wide.df <- bind_rows(
  lapply(split(sra.frc.mss.df, sra.frc.mss.df$Probe), function(df) {
    if (nrow(df) > 3) {
      df <- df %>% 
        group_by(Fraktion, Probe, wt_g) %>%
        summarize(yield = sum(yield), .groups = "drop")
    }
    return(df)
  })) %>%
  pivot_wider(names_from = Fraktion, values_from = yield) %>%
  rename(FPOM = fPOM, OPOM = oPOM, MOM = HF) %>%
  mutate(OPOM = ifelse(is.na(OPOM), wt_g - FPOM - MOM, OPOM))

# sum mass
sra.frc.mss.wide.df$mass_sum <- rowSums(sra.frc.mss.wide.df[ , c("FPOM", "OPOM", "MOM")])

# pivot longer and calculate mass pct
sra.frc.mss.long.df <- sra.frc.mss.wide.df %>%
  pivot_longer(cols = c("FPOM", "OPOM", "MOM"), names_to = "frc", values_to = "mass_g") %>%
  mutate(mass_pct = round(mass_g / mass_sum * 100, 1),
         depth = sapply(strsplit(Probe, "_(?!.*_)", perl = TRUE), "[[", 2),
         lyr_top = as.numeric(sapply(strsplit(depth, "[-]"), "[[", 1)),
         lyr_bot = as.numeric(sapply(strsplit(depth, "[-]"), "[[", 2)),
         year = as.numeric(sapply(strsplit(Probe, "_"), "[[", 3)),
         PMeco = sapply(strsplit(Probe, "_"), "[[", 1)) %>%
  arrange(lyr_bot)

# split by year
sra.frc.mss.long.01.df <- sra.frc.mss.long.df[sra.frc.mss.long.df$year == 2001, ]
sra.frc.mss.long.19.df <- sra.frc.mss.long.df[sra.frc.mss.long.df$year == 2019, ]
```

## External data
### Atmosphere

```{r atm14c-data}
Datm <- rbind(graven, future14C)
atm.14c <- data.frame(year = Datm[Datm$Date > 2000, "Date"],
                      d14c = Datm[Datm$Date > 2000, "NHc14"],
                      Type = "atmosphere")
```

### from C. Rasmussen ('01 C, N; '09 14C, frc mass, C, N)

```{r load-ras-01-09-data}
# Rasmussen 2001 data
## 2001 summary data
soc.2001 <- data.frame(read_excel("../data/external/sra_ras_sum/sierra_data_summary_2020.xlsx",
                                  sheet = "2001_bulk_data"))

# Rasmussen 2009 data
## 2009 fraction C, N, mass data
sra.09.frc.raw <- read_excel("../data/external/sra_ras_sum/sierra_data_summary_2020.xlsx", sheet = "2009_fraction_data") %>% type.convert(., as.is = TRUE) %>% data.frame

## 2009 summary data
sra.09.sum <- read_excel("../data/external/sra_ras_sum/sierra_data_summary_2020.xlsx", sheet = "Data_Summary_2018_paper") %>% type.convert(., as.is = TRUE) %>% data.frame

## 2009 bulk C
soc.09.blkC.df <- read_excel("../data/external/sra_ras_sum/sierra_data_summary_2020.xlsx", sheet = "2009_bulk_data") %>% type.convert(., as.is = TRUE) %>% data.frame

# Rasmussen 2009 14C data: ISRaD
## read ISRaD fx
sra.09.israd <- ISRaD.read.entry("../data/external/sra_ras_ISRaD/Rasmussen_2018.xlsx")

# get lyr data
sra.09.lyr.df <- sra.09.israd$Rasmussen_2018$layer

# get frc data
sra.09.frc.df <- merge(
  sra.09.israd$Rasmussen_2018$fraction,
  sra.09.israd$Rasmussen_2018$layer[, c("pro_name", "lyr_name", "lyr_bot", "lyr_top", "lyr_c_org", "lyr_n_tot", "lyr_soc", "lyr_obs_date_y")], by = c("pro_name", "lyr_name"))

## fill missing d14c data
ix <- which(is.na(sra.09.frc.df$frc_14c) & !is.na(sra.09.frc.df$frc_fraction_modern))
sra.09.frc.df[ix, "frc_14c"] <- convert_fm_d14c(
  fm = sra.09.frc.df[ix, "frc_fraction_modern"], 
  obs_date_y = sra.09.frc.df[ix, "lyr_obs_date_y"])

## reshape ISRaD data to merge with dens.df
sra.frc.14c <- sra.09.frc.df %>%
  mutate(PMeco = as.character(pro_name),
         PM = substr(PMeco, 1, 2),
         ECO = substr(PMeco, 3, 4),
         pro_name = paste0(PMeco, "_", lyr_obs_date_y),
         frc = ifelse(frc_property == "free light", "fPOM", 
                      ifelse(frc_property == "heavy", "minC", "oPOM")),
         Year = 2009) %>% # note that GR samples were technically collected in 2010...
  select(frc_fraction_modern, frc_fraction_modern_sigma, frc_14c, frc_14c_sigma, frc, PMeco, PM, ECO, Year, pro_name, lyr_top, lyr_bot) %>% 
  rename(F14C = frc_fraction_modern,
         err = frc_fraction_modern_sigma,
         frc_14c_err = frc_14c_sigma) 
```

# Analysis
## Misc. functions

```{r define-C-spline-fxs}
# depth spline for C percent, where d = vector of layer bottom depths
Cspline.fx <- function(df, var.name, d = c(10, 20, 30)) {
  bind_rows(lapply(split(df, df$pro_name), function(x) {
    depths(x) <- pro_name ~ lyr_top + lyr_bot
    x.mps <- mpspline(x, var.name = var.name, d = t(c(0, d)))
    x.std <- t(x.mps$var.std)
    df <- data.frame(c_pct = x.std, depth = row.names(x.std))
    df$depth <- gsub(" [^ ]*$", "", df$depth)
    return(df[1:length(d), ])
  }), .id = "pro_name")
}

# depth spline for monotonic cumulative C stocks; NB: input must be 2-col df w/ depth (1) and cmtv SOC (2)
SOCspline.fx <- function(x, depths, soc) {
  t0 <- data.frame(lyr_bot = 0)
  t0[[soc]] <- 0
  t0.x <- rbind(t0, x)
  
  # fit monotonic cubic spline
  sp <- spline(t0.x, method = "hyman") 
  
  # convert to class "spline" with smooth.spline fxn
  sp.ss <- smooth.spline(sp, all.knots = TRUE) 
  max.d <- max(x[ , 1])
  if (max.d < 31) {
    max.d <- 31
  }
  
  # predict at given depths (linear beyond last measured depth)
  spp <- predict(sp.ss, depths) 
  df <- data.frame(spp)
  colnames(df) <- c("lyr_bot", "lyr_soc") 
  
  # calculate soc per increment from cmtv values
  for(i in seq_along(df$lyr_bot)) {
    if(i == 1) {
      df$lyr_soc[i] <- df$lyr_soc[i]
    } else {
      df$lyr_soc[i] <- df$lyr_soc[i + 1] - df$lyr_soc[i]
    }
  }
  
  # return 
  df$lyr_bot <- df$lyr_bot + 1
  return(df[-length(df$lyr_soc), ])
}
```

## Bulk C
### 2001
```{r blkc-data-2001}
# Fraction samples combined 0-3 and 3-8 depth increments for BSrf and GRrf
## function for calculating depth-weighted average of first two depth increment C content
d1d2.fx <- function(df) {
  d1d2 <- data.frame(ID = paste(df$PMeco[1], df$pro_rep[1], df$lyr_top[1], df$lyr_bot[2], sep = "_"),
                     PMeco = df$PMeco[1],
                     mass_kgm2 = sum(df$mass_kgm2[1], df$mass_kgm2[2]),
                     c_pct = sum(df$c_pct[1] * ((df$lyr_bot[1] - df$lyr_top[1]) / df$lyr_bot[2]),
                                 df$c_pct[2] * ((df$lyr_bot[2] - df$lyr_top[2]) / df$lyr_bot[2])),
                     lyr_soc_kgm2 = sum(df$lyr_soc_kgm2[1], df$lyr_soc_kgm2[2]),
                     pro_name = df$pro_name[1],
                     lyr_top = df$lyr_top[1],
                     lyr_bot = df$lyr_bot[2])
  return(rbind(d1d2,
               df[3:nrow(df), ]))
}

# Create list
soc.2001.ls <- lapply(split(soc.2001, soc.2001$PMeco), function(df) {
  
  # remove NAs
  df <- type.convert(df[complete.cases(df), ])
  
  # filter < 36cm, rename c_pct, add mass and soc stock columns
  df <- df %>%
    filter(lyr_bot < 36) %>%
    rename(c_pct = C.) %>%
    mutate(mass_kgm2 = bd.g.cm3 * (lyr_bot - lyr_top) * fine.earth. * .1,
           lyr_soc_kgm2 = mass_kgm2 * c_pct * 10^-2,
           pro_name = paste(PMeco, pro_rep, sep = "_")) %>%
    select(ID, PMeco, mass_kgm2, c_pct, lyr_soc_kgm2, pro_name, lyr_top, lyr_bot)
  
  # combine 0-3, 3-8 cm depths for GRrf, BSrf
  if (df$PMeco[1] == "GRrf" | df$PMeco[1] == "BSrf") {
    df<- bind_rows(lapply(split(df, df$pro_name), d1d2.fx))
  }

  # calculate cmtv soc stocks
  ls <- split(df, df$pro_name)
  ls <- lapply(ls, function(x) {
    x <- x[order(x$lyr_bot), ] # make sure to order data
    x$lyr_soc_cmtv <- NA
    for(i in seq_along(x$lyr_bot)) {
      if(i == 1) {
        x$lyr_soc_cmtv[i] <- x$lyr_soc_kgm2[i]
      } else {
        x$lyr_soc_cmtv[i] <- x$lyr_soc_kgm2[i] + x$lyr_soc_cmtv[i-1] 
      }
    }
    return(x)
  })
  return(unsplit(ls, df$pro_name))
})

# summarize
soc.2001.sum.df <- bind_rows(soc.2001.ls) %>%
  group_by(PMeco, lyr_top, lyr_bot) %>%
  summarize(across(c(mass_kgm2, c_pct, lyr_soc_kgm2, lyr_soc_cmtv), 
            .fns = list(mean = mean, sd = sd)), .groups = "drop") %>%
  mutate(ID2 = paste0(PMeco, "_", lyr_top, "-", lyr_bot))
```

### 2009
```{r c-data-2009}
# calculate cumulative soc stocks for '09 data
sra.09.lyr.C <- unsplit(lapply(
  split(soc.09.blkC.df, soc.09.blkC.df$pro_name), function(x) {
    names(x)[which(names(x) == "bottom.mineral")] <- "lyr_bot"
    x$ECO <- tolower(x$Biome)
    x$PMeco <- paste0(x$PM, x$ECO)
    x <- x[order(x$lyr_bot), ] # make sure to order data
    x$lyr_soc_kgm2 <- x$BD_g_cm_3 * x$Thickness_cm * x$Soil_finefraction * .1 * x$C_pct
    x$lyr_soc_cmtv <- NA
    for(i in seq_along(x$lyr_bot)) {
      if(i == 1) {
        x$lyr_soc_cmtv[i] <- x$lyr_soc_kgm2[i]
      } else {
        x$lyr_soc_cmtv[i] <- x$lyr_soc_kgm2[i] + x$lyr_soc_cmtv[i-1] 
      }
    }
    return(x)
  }), soc.09.blkC.df$pro_name)
```


## Fraction C
```{r merge-frc-mass-C}
## merge C and mass data
# '01
sra.frc.mss.C.01.df <- merge(
  bind_rows(
    lapply(sra.frc.2001.ls, function(ls) bind_rows(ls, .id = "PMeco")), .id = "frc"),
  sra.frc.mss.long.01.df, by = c("year", "PMeco", "lyr_bot", "lyr_top", "frc")) %>% 
  mutate(ID2 = sub("comp_2001_", x = ID, replacement = ""))

# calculate C weights
sra.frc.mss.C.01.df$mass_c_g <- sra.frc.mss.C.01.df$mass_sum *(sra.frc.mss.C.01.df$mass_pct / 100) * (sra.frc.mss.C.01.df$C / 100)

# add lyr C
sra.frc.mss.C.01.df$lyr_c_pct <- unlist(soc.2001.sum.df[
  match(sra.frc.mss.C.01.df$ID2, soc.2001.sum.df$ID2), "c_pct_mean"])

# calculate fraction percent of total C
sra.frc.mss.C.01.df$frc_c_pct <- sra.frc.mss.C.01.df$mass_c_g / (sra.frc.mss.C.01.df$lyr_c_pct * sra.frc.mss.C.01.df$mass_sum * 10^-2) * 10^2

# relevel fraction factor
sra.frc.mss.C.01.df$frc <- factor(sra.frc.mss.C.01.df$frc, 
                                  levels = c("FPOM", "OPOM", "MOM"))

# rescale to 100% for deepest depth
sra.frc.mss.C.01.rescale.df <- bind_rows(
    lapply(split(sra.frc.mss.C.01.df, sra.frc.mss.C.01.df$PMeco), function(df) {
      bind_rows(lapply(split(df, df$depth), function(f) {
        if (any(f$frc_c_pct > 100)) {
         f$frc_c_pct <- f$mass_c_g / sum(f$mass_c_g) * 10^2
        } 
        return(f)
      }))
    }))

# '09
# sra.09.frc.C$frc_c_perc


# '19
sra.frc.mss.C.19.df <- merge(
  bind_rows(
    lapply(sra.frc.2019.ls, function(ls) bind_rows(ls, .id = "PMeco")), .id = "frc"),
  sra.frc.mss.long.19.df, by = c("year", "PMeco", "lyr_bot", "lyr_top", "frc")) %>% 
  mutate(ID2 = sub("comp_2019_", x = ID, replacement = ""))

# calculate C weights
sra.frc.mss.C.19.df$mass_c_g <- sra.frc.mss.C.19.df$mass_sum *(sra.frc.mss.C.19.df$mass_pct / 100) * (sra.frc.mss.C.19.df$C / 100)

# add lyr C
sra.frc.mss.C.19.df$lyr_c_pct <- unlist(sra.blk.2019.sum.df[
  match(sra.frc.mss.C.19.df$ID2, sra.blk.2019.sum.df$ID2), "C_mean"])

# calculate fraction percent of total C
sra.frc.mss.C.19.df$frc_c_pct <- sra.frc.mss.C.19.df$mass_c_g / (sra.frc.mss.C.19.df$lyr_c_pct * sra.frc.mss.C.19.df$mass_sum * 10^-2) * 10^2
```

```{r plot-frcC-pct-fx}
# box plot fx
frc_c_pct.plot.fx <- function(df, fill_var) {
  
  # set fill variable and guides
  quo_fill_var <- sym(fill_var)
  if (fill_var == "PM") {
    fill_vals <- c("AN" = andesite, "BS" = basalt, "GR" = granite)
  } else {
    fill_vals <- c("pp" = warm, "wf" = cool, "rf" = cold)
  }
  
  # plot
 df %>%
  mutate(frc = factor(frc, levels = c("FPOM", "OPOM", "MOM"))) %>%
  ggplot(., aes(frc, frc_c_pct)) +
  geom_boxplot(aes(fill = !! quo_fill_var), position = "dodge") +
  scale_fill_manual(name = NULL,
                    values = fill_vals) +
  facet_grid(cols = vars(depth)) +
  ylab("C partitioning (%)") +
  xlab(NULL) +
  theme_bw() +
  theme(panel.grid = element_blank()) 
}
```

```{r plot-frcC-pct-01}
# 2001
## prep fx
sra.frc.mss.C.01.prep.fx <- function(df) {
  bind_rows(
    lapply(split(df, df$PMeco), function(d) {
      bind_rows(lapply(split(d, d$frc), function(f) {
        f <- f[order(f$lyr_bot), ]
        f$depth <- seq(1, nrow(f))
        return(f)
      }))
    }))
}

## PM
frc_c_pct.plot.fx(sra.frc.mss.C.01.prep.fx(sra.frc.mss.C.01.rescale.df), 
                  fill_var = "PM")

## ECO
frc_c_pct.plot.fx(sra.frc.mss.C.01.prep.fx(sra.frc.mss.C.01.rescale.df), 
                  fill_var = "ECO")
```

```{r plot-frcC-pct-19}
# 2019
frc_c_pct.plot.fx(sra.frc.mss.C.19.df, "PM")
frc_c_pct.plot.fx(sra.frc.mss.C.19.df, "ECO")
```

## Spline '01, '09
```{r spline-c-data}
# spline fit fxs for fraction SOC stocks
## Mass preserving spline (quadratic)
mpspline.frc.fx <- function(frc.ls) {
  lapply(
    split(frc.ls, frc.ls$frc), function(df) {
      lapply(split(df, df$PMeco), function(x) {
        
        # check for single obs data
        if (nrow(x) > 1) {
          
          # make sure to order data
          x <- x[order(x$lyr_bot), ] 
          
          # calculate cumulative C mass
          x$mass_c_cmtv <- NA
          for(i in seq_along(x$lyr_bot)) {
            if(i == 1) {
              x$mass_c_cmtv[i] <- x$mass_c_g[i]
            } else {
              x$mass_c_cmtv[i] <- x$mass_c_g[i] + x$mass_c_cmtv[i-1] 
            }
          }
          
          # convert to soil profile collection obj and run mpspline
          depths(x) <- PMeco ~ lyr_top + lyr_bot
          x.mps <- suppressMessages(
            mpspline(x, var.name = "mass_c_cmtv", show.progress = FALSE))
          
          # extract 1 cm increment data
          ix <- which(!is.na(x.mps$var.1cm))
          df <- data.frame(lyr_bot = seq(1, length(ix)),
                           lyr_soc = x.mps$var.1cm[ix])
          
          # check for NA values up to 30 cm
          if (length(ix) < 30) {
            # convert to class "spline" with smooth.spline fxn
            sp.ss <- smooth.spline(df)
          
            # predict for NA values up to 31 cm (linear beyond last measured depth)
            std <- seq(0, 30) # in cm 
            sp <- predict(sp.ss, std) 
            df <- data.frame(sp)
            colnames(df) <- c("lyr_bot","lyr_soc") 
          }
          
          
          # extract top 30 cm and calculate 1 cm SOC values
          for(i in seq_along(df$lyr_soc)) {
            if(i == 1) {
              df$lyr_soc[i] <- df$lyr_soc[i]
            } else {
              df$lyr_soc[i] <- df$lyr_soc[i + 1] - df$lyr_soc[i]
            }
          }
          
          # return 
          return(df$lyr_soc[-length(df$lyr_soc)])
        }
      })
    })
}

## depth spline alternative (linear for two increment fits...)
SOCspline.fx <- function(frc.ls) {
  lapply(
    split(frc.ls, frc.ls$frc), function(df) {
      lapply(split(df, df$PMeco), function(x) {
    
        # check for single obs data
        if (nrow(x) > 1) {
          
          # make sure to order data
          x <- x[order(x$lyr_bot), ] 
          
          # calculate cumulative C mass
          x$mass_c_cmtv <- NA
          for(i in seq_along(x$lyr_bot)) {
            if(i == 1) {
              x$mass_c_cmtv[i] <- x$mass_c_g[i]
            } else {
              x$mass_c_cmtv[i] <- x$mass_c_g[i] + x$mass_c_cmtv[i-1] 
            }
          }
          
          # fit monotonic cubic spline
          sp <- spline(x[ , c("lyr_bot", "mass_c_cmtv")], method = "hyman") 
          
          # convert to class "spline" with smooth.spline fxn
          sp.ss <- smooth.spline(sp) 
          
          # predict 1 cm increments to 30 cm (linear beyond last measured depth)
          std <- seq(0, 30) # in cm 
          sp <- predict(sp.ss, std) 
          df <- data.frame(sp)
          colnames(df) <- c("lyr_bot","lyr_soc") 
          
          # calculate SOC per increment
          for(i in seq_along(df$lyr_bot)) {
            if(i == 1) {
              df$lyr_soc[i] <- df$lyr_soc[i]
            } else {
              df$lyr_soc[i] <- df$lyr_soc[i + 1] - df$lyr_soc[i]
            }
          }
          df$lyr_bot <- df$lyr_bot + 1
          
          # return 
          return(df[-length(df$lyr_soc), ])
        }
      })
    })
}
```

```{r run-cspline-frc}
# fraction C stocks
soc.2001.frcSOC.sp <- mpspline.frc.fx(sra.frc.mss.C.01.df)

# fraction C stocks
soc.2009.frcSOC.sp <- mpspline.frc.fx(sra.frc.mss.C.01.df) 
```

## Fraction 14C
### Depth profiles

```{r shape-dens14C-df}
# function for splitting sample names and extracting values from ams list
uScoreSplit.fx <- function(df, ix) sapply(strsplit(df[["Probe"]], "_"), "[[", ix)

# create df
dens.df <- bind_rows(lapply(ams_results_ls, function(ls) {
  df.ex <- function(x, frc) {
    bind_rows(lapply(x, function(df) {
      df[grep(frc, df$Probe), 2:6]
    }))
  }
  fPOM <- df.ex(ls, "FPOM")
  oPOM <- df.ex(ls, "OPOM")
  minC <- df.ex(ls, "MOM")
  return(cbind(rbind(fPOM, oPOM, minC), frc = c(rep("fPOM", nrow(fPOM)),
                                                rep("oPOM", nrow(oPOM)),
                                                rep("minC", nrow(minC)))))
})) %>%
  mutate(PMeco = uScoreSplit.fx(., 2),
         PM = substr(PMeco, 1, 2),
         ECO = factor(substr(PMeco, 3, 4), levels = c("pp", "wf", "rf")),
         Year = uScoreSplit.fx(., 4),
         pro_name = paste0(PMeco, "_", Year),
         depths = uScoreSplit.fx(., 5),
         lyr_top = as.numeric(sapply(strsplit(depths, "-"), "[[", 1)),
         lyr_bot = as.numeric(sapply(strsplit(depths, "-"), "[[", 2))) %>%
  rename(frc_14c = "∆14C.(‰)",
         frc_14c_err = "err.(‰)") %>%
  select(-c(Probe, depths))

# add '09 data
dens.01.09.19.df <- rbind(dens.df, sra.frc.14c) %>%
  mutate(pm = ifelse(PM == "AN", "andesite", 
                     ifelse(PM == "BS", "basalt", "granite")),
         eco = factor(ifelse(ECO == "pp", "warm", ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         year = as.numeric(Year))
```

``` {r plot-profiles}
# pro plot fx
dens.pro.p.fx <- function(df, year, leg.pos = "right") {
  
  # filter df by year
  df <- df[df$year == year, ]
  
  # get atm 14C
  atm.14c <- atm.14c[atm.14c$year == year + .5, "d14c"]
  
  # set shape to 2001 defaults
  shp.v <- c("warm" = 15, "cool" = 17, "cold" = 16)
  alf <- 1
  lnt.v <- c("2001" = 1)
  stroke <- 1
  ln.sz <- .5
  
  # change shape and alpha as needed
  if (year == 2009) {
    alf <- .6
    lnt.v <- c("2009" = 2)
  } else if (year == 2019) {
    shp.v <- c("warm" = 0, "cool" = 2, "cold" = 1)
    lnt.v <- c("2019" = 3)
    stroke <- 1.2
    ln.sz <- 1
  }
  
  # plot fx
  ggplot(df, aes(frc_14c, lyr_bot, color = frc)) +
    geom_vline(xintercept = atm.14c, color = "gray") +
    geom_point(aes(shape = eco), size = 3, alpha = alf, stroke = stroke) +
    geom_path(aes(linetype = Year), size = ln.sz) +
    scale_color_manual(name = NULL,
                       values = c("minC" = "#9b003f",
                                  "fPOM" = "#3f9b00",
                                  "oPOM" = "#0047af")) +
    scale_linetype_manual(name = NULL, values = lnt.v) +
    scale_shape_manual(name = NULL, values = shp.v) +
    facet_grid(rows = vars(eco), cols = vars(pm)) +
    scale_y_reverse() +
    theme_bw() +
    theme(panel.grid = element_blank(),
          legend.position = leg.pos)
}
```

```{r plot-dens-pros}
# plot profiles by year and fraction type
dens.pro.p.fx(dens.01.09.19.df, 2001)
dens.pro.p.fx(dens.01.09.19.df, 2019)
dens.pro.p.fx(dens.01.09.19.df, 2009)
```

```{r spline-14C-frc}
# run mpspline on fraction modern data for '01, '09
dens.01.09.df <- dens.01.09.19.df[which(dens.01.09.19.df$year != 2019), ]
dens.01.09.ls.sp <- lapply(
  split(dens.01.09.df, dens.01.09.df$frc), function(df) {
    lapply(split(df, df$pro_name), function(x) {
      if (length(which(!is.na(x$F14C))) > 1) {
       depths(x) <- pro_name ~ lyr_top + lyr_bot
        x.mps <- suppressMessages(
          mpspline(x, var.name = "F14C", show.progress = FALSE))
        x.mps$var.1cm <- x.mps$var.1cm[1:30]
        
        # fill NA w/ smooth.spline prediction (linear)
        ix <- which(is.na(x.mps$var.1cm))
        if (length(ix) > 0) {
          sp.ss <- smooth.spline(x.mps$var.1cm[-ix])
          sp <- predict(sp.ss, ix)
          x.mps$var.1cm[ix] <- sp$y
        }
        return(x.mps) 
      }
    })
  })
```

```{r plot-frc-fm-splines}
# plot for determining best extrapolation fx
frc.fm.sp.plot.fx <- function(fm.sp.ls) {
  lapply(fm.sp.ls, function(ls) {
    p <- bind_rows(lapply(seq_along(ls), function(i) {
      if (!is.null(ls[[i]])) {
        df <- data.frame(t(do.call(rbind, list(ls[[i]][[1]], ls[[i]][[4]]))))
        df$lyr_bot <- seq(1, length(df[ , 1]))
        df$PM <- substr(df[ , 1], 1, 2)
        df$ECO <- substr(df[ , 1], 3, 4)
        df$Year <- ifelse(substr(df[ , 1], 6, 9) == "2010", "2009",
                          substr(df[ , 1], 6, 9))
        colnames(df)[2] <- "fm"
        df$fm <- as.numeric(as.character(df$fm))
        return(df[ , -1])
      }
    })) %>%
    ggplot(., aes(fm, lyr_bot, color = PM, linetype = Year)) +
    geom_path() +
    scale_color_manual(name = NULL,
                       values = c("AN" = andesite,
                                  "BS" = basalt,
                                  "GR" = granite)) +
    scale_linetype_manual(name = NULL,
                          values = c("2001" = 1,
                                     "2009" = 2)) +
    scale_x_continuous(limits = c(.75, 1.25)) +
    scale_y_reverse() +
    facet_grid(rows = vars(ECO), cols = vars(PM)) +
    theme_bw() +
    theme(panel.grid = element_blank())
  })
}
dens.01.09.ls.sp.p <- frc.fm.sp.plot.fx(dens.01.09.ls.sp)
```

### C-weighted splines

```{r cwt-14c}
# fractions
cwt.frc.fx <- function(soc.ls) {
  lapply(soc.ls, function(pro_ls) {
    cwt.ls <- lapply(pro_ls, function(soc) {
      d <- seq(10, 30, 10)
      c <- vector(mode = "list", length = length(d))
      for(j in seq_along(d)) {
        if(j == 1) {
          # first depth increment
          c[[j]] <- soc[1:d[j]]
        } else {
          # following depth increments
          c[[j]] <- soc[(d[j-1]+1):d[j]] 
        }
      }
      return(unlist(lapply(c, function(x) x / sum(x, na.rm = TRUE))))
    })
  })
}

# 2001
cwt.19.01.frc <- cwt.frc.fx(soc.2001.frcSOC.sp)

# 2009
# cwt.19.09 <- cwt.frc.fx(soc.2009.frcSOC.sp)

## calculate fm_wts
## '19 depths
# 2001
fm.wtd.19.01 <- lapply(seq_along(dens.01.09.ls.sp), function(i) {
  
  # filter null sites
  ls <- Filter(Negate(is.null), 
               dens.01.09.ls.sp[[i]][grepl("2001", names(dens.01.09.ls.sp[[i]]))])
  
  # check that cwt list and fm lists are equal in length
  if (length(ls) == length(cwt.19.01.frc[[i]])) {
    fm.ls <- lapply(seq_along(cwt.19.01.frc[[i]]), function(j) {
      
      # cbind cwts, fm
      df <- data.frame(cwt = cwt.19.01.frc[[i]][[j]],
                       fm = ls[[j]][["var.1cm"]])
      
      # calculate wtd fm
      df$fm_wt <- df$fm * df$cwt
      
      # summarize for target intervals
      df.sum <- data.frame(
        lyr_bot = c(10, 20, 30),
        fm = c(
          sum(df[1:10, "fm_wt"]), 
          sum(df[11:20, "fm_wt"]), 
          sum(df[21:30, "fm_wt"]))) 
    
      # return
      return(df.sum)
    })
    
    # restore names
    names(fm.ls) <- names(cwt.19.01.frc[[i]])
    
    # return wtd fm list
    return(fm.ls)
  }
})
names(fm.wtd.19.01) <- names(cwt.19.01.frc)
```

```{r prep-cwt-14c-plot}
# make df for splined '01 data
dens.01.df <- bind_rows(
  lapply(fm.wtd.19.01, function(ls) bind_rows(ls, .id = "PMeco")), .id = "frc") %>%
  mutate(pm = ifelse(substr(PMeco, 1, 2) == "AN", "andesite", 
                     ifelse(substr(PMeco, 1, 2) == "BS", "basalt", "granite")), 
         eco = factor(
           ifelse(substr(PMeco, 3, 4) == "pp", "warm", 
                  ifelse(substr(PMeco, 3, 4) == "wf", "cool", "cold")),
           levels = c("warm", "cool", "cold")),
         year = 2001,
         Year = as.character(year),
         frc_14c = convert_fm_d14c(fm = fm, obs_date_y = year, verbose = FALSE),
         frc = factor(frc, 
                      levels = c("FPOM", "OPOM", "MOM"), 
                      labels = c("fPOM", "oPOM", "minC"))) %>%
  rename(F14C = fm)

# combine '01, '19 data
dens.01.19.df <- rbind(
  dens.01.df,
  dens.01.09.19.df[dens.01.09.19.df$year == 2019, 
                   names(dens.01.09.19.df) %in% names(dens.01.df)])

# plot fc
plot.d14c.ts.fx <- function(df, compare_var) {
  
  # set quo_var
  quo_var <- sym(compare_var)
  
  # set facet var and color scales
  if (compare_var == "pm") {
    f_var <- sym("eco")
    cvals <- c("andesite" = andesite, "basalt" = basalt, "granite" = granite) 
  } else {
    f_var <- sym("pm")
    cvals <- c("warm" = warm, "cool" = cool, "cold" = cold)
  }
  
  # split by depth and plot
  lapply(split(df, df$lyr_bot), function(x) {
    x %>%
      filter(frc != "minC") %>%
    ggplot(., aes(year, frc_14c, color = !! quo_var)) +
    geom_line(data = atm.14c, aes(year, d14c), linetype = 3, color = "gray") +
    geom_line() +
    geom_point(aes(shape = eco), size = 2) +
    scale_color_manual(name = NULL, values = cvals) +
    scale_shape_manual(name = NULL,
                       values = c("warm" = 15,
                                  "cool" = 17,
                                  "cold" = 16)) +
    scale_x_continuous(breaks = c(2001, 2019)) +
    facet_grid(rows = vars(frc), cols = vars(!! f_var)) +
    theme_bw() +
    theme(panel.grid = element_blank())
  })
}
```

```{r plot-cwt-14c}
# plot
plot.d14c.ts.fx(dens.01.19.df, "pm")
plot.d14c.ts.fx(dens.01.19.df, "eco")
```

```{r plot-LF-inc}
# load data
load("/Users/jeff/sra-ts/source/sra.all.min.RData")

# long df
dens.blk.inc.min <- merge(
  sra.19.01.inc.df %>% mutate(Year = as.character(year)),
  dens.df, by = c("PM", "ECO", "PMeco", "Year", "lyr_bot"))

# convert dens.df to wide
dens.01.19.df.w <- dens.01.19.df %>%
  filter(frc != "minC") %>%
  select(PMeco, year, frc, lyr_bot, frc_14c) %>%
  pivot_wider(names_from = frc, values_from = frc_14c)
dens.inc.min.w <- merge(
  sra.19.01.inc.df,
  dens.01.19.df.w)

# plot inc v LF
# plot profiles by year and fraction type
dens.inc.min.w %>%
  filter(d14c > -70) %>%
  ggplot(., aes(d14c, fPOM, color = PM, shape = ECO)) +
  geom_vline(xintercept = 0, color = "lightgray") +
  geom_hline(yintercept = 0, color = "lightgray") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmax = d14c_max, xmin = d14c_min), height = 1) +
  scale_color_manual(name = "Parent material",
                     values = c("AN" = andesite,
                                "BS" = basalt,
                                "GR" = granite)) +
  scale_shape_manual(name = "Climate",
                     values = c("pp" = 15,
                                "wf" = 17,
                                "rf" = 16)) +
  # coord_cartesian(xlim = c(-120, 110), ylim = c(-120, 110)) +
  facet_grid(cols = vars(lyr_bot)) + 
  theme_bw() +
  theme(panel.grid = element_blank(),
        aspect.ratio = 1)
```

```{r plot-c-n-cn}
# plot depth profiles
# plot fx
frc.pro.plot <- function(df, year, fraction, x) {
  quo_x <- sym(x)
  xlab <- ifelse(x == "CN", "CN", paste(x, "(%)"))
  df$ECO <- factor(df$ECO, levels = c("pp", "wf", "rf"))
  df <- df[order(df$lyr_bot), ]
  ggplot(df, aes(!! quo_x, lyr_bot, color = PM, shape = ECO)) +
    geom_hline(yintercept = 0) +
    geom_point(size = 3) +
    geom_path() +
    scale_y_reverse() +
    scale_x_continuous() +
    scale_color_manual(name = "Parent material",
                       labels = c("AN" = "andesite",
                                  "BS" = "basalt",
                                  "GR" = "granite"),
                       values = c("AN" = andesite, 
                                  "BS" = basalt, 
                                  "GR" = granite)) +
    scale_shape_manual(name = "Climate",
                       labels = c("pp" = "warm",
                                  "rf" = "cold",
                                  "wf" = "cool"),
                       values = c("pp" = 15, 
                                  "rf" = 16, 
                                  "wf" = 17)) +
    xlab(xlab) +
    ylab("Depth (cm)") +
    ggtitle(paste(year, fraction)) +
    theme_bw() +
    theme(panel.grid.minor = element_blank())
}

# Combine profiles for plotting
frc.C.01.plot.ls <- lapply(sra.frc.2001.ls, bind_rows, .id = "fraction")
lapply(seq_along(frc.C.01.plot.ls), function(i) {
  frc.pro.plot(frc.C.01.plot.ls[[i]], 2001, names(frc.C.01.plot.ls)[i], "C")
})

frc.C.19.plot.ls <- lapply(sra.frc.2019.ls, bind_rows, .id = "fraction")
lapply(seq_along(frc.C.19.plot.ls), function(i) {
  frc.pro.plot(frc.C.19.plot.ls[[i]], 2019, names(frc.C.19.plot.ls)[i], "C")
})

# Calculate and plot CN
lapply(seq_along(frc.C.01.plot.ls), function(i) {
  frc.C.01.plot.ls[[i]][["CN"]] <- frc.C.01.plot.ls[[i]][["C"]] / frc.C.01.plot.ls[[i]][["N"]]
  frc.pro.plot(frc.C.01.plot.ls[[i]], 2001, names(frc.C.01.plot.ls)[i], "CN")
})
lapply(seq_along(frc.C.19.plot.ls), function(i) {
  frc.C.19.plot.ls[[i]][["CN"]] <- frc.C.19.plot.ls[[i]][["C"]] / frc.C.19.plot.ls[[i]][["N"]]
  frc.pro.plot(frc.C.19.plot.ls[[i]], 2019, names(frc.C.19.plot.ls)[i], "CN")
})
```

```{r plot-frc-mass-losses}
# calc loss, drop samples without all weights
sra.frc.mss.lss.df <- sra.frc.mss.wide.df
sra.frc.mss.lss.df$sum <- rowSums(sra.frc.mss.lss.df[ , c("fPOM", "oPOM", "HF")])
sra.frc.mss.lss.df$loss <- sra.frc.mss.lss.df$wt_g - sra.frc.mss.lss.df$sum
sra.frc.mss.lss.df$loss_pct <- (sra.frc.mss.lss.df$loss / sra.frc.mss.lss.df$wt_g) * 100
  
# summarize losses by PM, ECO
sra.frc.mss.lss.df$PM <- substr(sra.frc.mss.lss.df$Probe, 1, 2)
sra.frc.mss.lss.df$ECO <- factor(substr(sra.frc.mss.lss.df$Probe, 3, 4), 
                                 levels = c("pp", "wf", "rf"))
sra.frc.mss.lss.df$year <- as.numeric(substr(sra.frc.mss.lss.df$Probe, 11, 14))
sra.frc.mss.lss.df$depth <- sapply(
  strsplit(sra.frc.mss.lss.df$Probe, "_(?!.*_)", perl = TRUE), 
  "[[", 2)
sra.frc.mss.lss.df$lyr_bot <- as.numeric(ifelse(nchar(sra.frc.mss.lss.df$depth) == 3, substr(sra.frc.mss.lss.df$depth, 3, 3), ifelse(nchar(sra.frc.mss.lss.df$depth) == 4, substr(sra.frc.mss.lss.df$depth, 3, 4), substr(sra.frc.mss.lss.df$depth, 4, 5))))

## summarize
# summary(lm(loss_pct ~ PM + ECO + year + lyr_bot, 
#            sra.frc.mss.lss.df[-which(sra.frc.mss.lss.df$Probe == "BSpp_comp_2001_18-28"), ]))
summary(lm(loss_pct ~ PM + ECO, 
           sra.frc.mss.lss.df[-which(sra.frc.mss.lss.df$Probe == "BSpp_comp_2001_18-28"), ]))

# plot
sra.frc.mss.lss.df %>%
  rename(`Mass loss (%)` = loss_pct) %>%
  mutate(eco = factor(ifelse(ECO == "pp", "warm",
                             ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(ECO, `Mass loss (%)`, color = pm, shape = eco)) +
  geom_hline(yintercept = 0, color = "black") +
  geom_point(size = 3) +
  scale_color_manual(values = c("andesite" = andesite,
                                "basalt" = basalt,
                                "granite" = granite)) +
  scale_shape_manual(values = c("warm" = 15,
                                "cool" = 17,
                                "cold" = 16)) +
  facet_grid(cols = vars(year)) +
  theme_bw() +
  theme(panel.grid = element_blank())
```

Interestingly, it appears that AN soils have proportionally LESS minC by mass than do GR or BS soils, significantly so at depth. Why would this be? Possibly because AN soils have higher losses (DOC) during fractionation?

```{r calc-frc-C-distr-err}
# make wide dataframe for 2019 frc data
merge.vars <- c("year", "PM", "ECO", "lyr_bot")
sra.frc.2019.df <- merge(
  merge(bind_rows(sra.frc.2019.ls$FPOM)[, c(merge.vars, "C", "N")],
        bind_rows(sra.frc.2019.ls$OPOM)[, c(merge.vars, "C", "N")],
        by = merge.vars, suffixes = c("_fPOM", "_oPOM")),
  bind_rows(sra.frc.2019.ls$MOM)[, c(merge.vars, "C", "N")], by = merge.vars) %>%
  rename(C_minC = C, N_minC = N)

# fill missing oPOM data
sra.frc.mss.wide.fill.df <- sra.frc.mss.lss.df
sra.frc.mss.wide.fill.df$oPOM <- ifelse(
  is.na(sra.frc.mss.wide.df$oPOM),
  sra.frc.mss.wide.df$wt_g - (sra.frc.mss.wide.df$fPOM + sra.frc.mss.wide.df$HF),
  sra.frc.mss.wide.df$oPOM)

# calculate mass precentages
sra.frc.mss.wide.fill.df <- sra.frc.mss.wide.fill.df %>%
  mutate(fPOM_mass_frac = fPOM / wt_g,
         oPOM_mass_frac = oPOM / wt_g,
         minC_mass_frac = HF / wt_g,
         PMeco = paste0(PM, ECO))

# # model
# summary(lm(fPOM_mass_frac ~ PM + ECO, 
#            sra.frc.mss.wide.fill.df[sra.frc.mss.wide.fill.df$lyr_bot == 10 & sra.frc.mss.wide.fill.df$year == 2019,]))
# summary(lm(oPOM_mass_frac ~ PM + ECO, 
#            sra.frc.mss.wide.fill.df[sra.frc.mss.wide.fill.df$lyr_bot == 10 & sra.frc.mss.wide.fill.df$year == 2019,]))
# summary(lm(minC_mass_frac ~ PM + ECO, 
#            sra.frc.mss.wide.fill.df[sra.frc.mss.wide.fill.df$lyr_bot == 10 & sra.frc.mss.wide.fill.df$year == 2019,]))

# plot
sra.frc.mss.fill.plot.df <- sra.frc.mss.wide.fill.df %>%
  pivot_longer(cols = contains("mass_frac"), names_to = "Fraction", values_to = "Mass percent") %>%
  mutate(Fraction = factor(Fraction,
                           levels = c("fPOM_mass_frac", "oPOM_mass_frac", "minC_mass_frac"),
                           labels = c("fPOM_mass_frac" = "fPOM",
                                      "oPOM_mass_frac" = "oPOM", 
                                      "minC_mass_frac" = "minC")))

# 2019
sra.frc.mss.fill.plot.df %>%
  filter(year == 2019) %>%
  ggplot(., aes(PMeco, `Mass percent`, fill = Fraction)) +
  geom_hline(yintercept = 1, color = "black") +
  geom_col() +
  facet_grid(rows = vars(depth)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())

# 2001 too hard to plot with all depths
sra.frc.mss.fill.plot.df %>%
  filter(year == 2001) %>%
  group_by(PMeco, Fraction) %>%
  summarize(`Mass percent` = mean(`Mass percent`)) %>%
  ggplot(., aes(PMeco, `Mass percent`, fill = Fraction)) +
  geom_hline(yintercept = 1, color = "black") +
  geom_col() +
  theme_bw() +
  theme(panel.grid.minor = element_blank())

# add lyr_C
load("/Users/jeff/sra-ts/source/sra.2001.ls.RData")
load("/Users/jeff/sra-ts/source/sra.2019.ls.RData")

# make df from list objects
sra.soc.2019.df <- bind_rows(sra.2019.ls) %>%
  filter(lyr_bot < 31) %>%
  select(PM, ECO, lyr_bot, Year, lyr_soc, C, mass_kgm2) %>%
  group_by(PM, ECO, lyr_bot, Year) %>%
  summarize(across(.cols = c(lyr_soc, C, mass_kgm2), .fns = mean), .groups = "drop") %>%
  rename(year = Year, c_pct_lyr = C)
sra.soc.2001.df <- bind_rows(sra.2001.ls) %>%
  select(PM, ECO, lyr_bot, lyr_soc_kgm2, C., bd.g.cm3, fine.earth.) %>%
  group_by(PM, ECO, lyr_bot) %>%
  summarize(across(.cols = c(lyr_soc_kgm2, C., bd.g.cm3, fine.earth.), .fns = mean), .groups = "drop") %>%
  rename(c_pct_lyr = C.,
         lyr_soc = lyr_soc_kgm2,
         bd = bd.g.cm3,
         fineEarth = fine.earth.) %>%
  mutate(year = 2001)

# merge w/ frc lists
sra.frc.soc.2001.ls <- lapply(lapply(sra.frc.2001.ls, bind_rows), function(df) {
  merge(df, sra.soc.2001.df, by = c("PM", "ECO", "year", "lyr_bot")) %>%
    select(-"ID")
})
sra.frc.soc.2001.ls$MOM <- sra.frc.soc.2001.ls$MOM %>%
  mutate(C = NA, N = NA)
sra.frc.soc.2019.ls <- lapply(lapply(sra.frc.2019.ls, bind_rows), function(df) {
  merge(df, sra.soc.2019.df, by = c("PM", "ECO", "year", "lyr_bot")) %>%
    select(-"ID")
})
# add fineEarth to 2019 data
sra.frc.soc.01.19.ls <- lapply(seq_along(sra.frc.soc.2019.ls), function(i) {
  rbind(sra.frc.soc.2019.ls[[i]], sra.frc.soc.2001.ls[[i]])
})
names(sra.frc.soc.01.19.ls) <- names(sra.frc.soc.2019.ls)

# merge mass frc
sra.frc.mss.fill.long.ls <- split(sra.frc.mss.fill.plot.df, sra.frc.mss.fill.plot.df$Fraction)
sra.frc.mss.fill.long.ls <- lapply(sra.frc.mss.fill.long.ls, function(df) {
  df[ , c("PM", "ECO", "year", "lyr_bot", "Mass percent")]
})
sra.frc.soc.ls <- mapply(
  merge,
  sra.frc.soc.01.19.ls,
  sra.frc.mss.fill.long.ls,
  SIMPLIFY = FALSE)

# Calculate C pct of layer, absolute C, stock per fraction
sra.frc.soc.df <- bind_rows(sra.frc.soc.ls, .id = "Fraction")
sra.frc.soc.df$frc_C_lyr <- sra.frc.soc.df$C * 10^-2 * sra.frc.soc.df$`Mass percent`
sra.frc.soc.wide.df <- pivot_wider(
  sra.frc.soc.df, 
  id_cols = c("year", "PM", "ECO", "lyr_bot", "lyr_soc", "c_pct_lyr", "bd"), 
  names_from = c("Fraction"), values_from = c("frc_C_lyr", "C", "Mass percent")) %>%
  merge(., sra.frc.mss.wide.fill.df[ , c("PM", "ECO", "lyr_bot", "year", "wt_g")])

# sum gC frc
sra.frc.soc.wide.df$c_pct_lyr_frc <- rowSums(sra.frc.soc.wide.df[, c("frc_C_lyr_FPOM", "frc_C_lyr_OPOM", "frc_C_lyr_MOM")]) * 100
sra.frc.soc.wide.df$C_LOST <- sra.frc.soc.wide.df$c_pct_lyr - sra.frc.soc.wide.df$c_pct_lyr_frc
sra.frc.soc.wide.df$soc_lost <- sra.frc.soc.wide.df$C_LOST * sra.frc.soc.wide.df$bd
sra.frc.soc.wide.df$pctSOC_lost <- sra.frc.soc.wide.df$soc_lost / sra.frc.soc.wide.df$lyr_soc
```

```{r plot-c-loss}
# 2001
# sra.frc.soc.wide.df %>%
#   filter(year == 2001) %>%
#   mutate(PMeco = paste0(PM, ECO)) %>%
#   ggplot(., aes(PMeco, soc_lost)) +
#   geom_col() +
#   facet_grid(rows = vars(lyr_bot)) +
#   theme_bw() +
#   theme(panel.grid.minor = element_blank())

# 2019
sra.frc.soc.wide.df %>%
  filter(year == 2019) %>%
  mutate(Site = factor(paste0(PM, ECO), 
                       levels = c("ANpp", "ANwf", "ANrf", 
                                  "BSpp", "BSwf", "BSrf", 
                                  "GRpp", "GRwf", "GRrf")),
         `C lost (% of total stock)` = pctSOC_lost * 100) %>%
  ggplot(., aes(Site, `C lost (% of total stock)`)) +
  geom_col() +
  facet_grid(rows = vars(lyr_bot)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```

```{r thermal-data}
# load thermogram data and combine
ANwf.20.HF_tml <- read.csv("../data/external/sra_thml_14C_stoner/smooth_ANwf MOM_RPO.csv")
GRwf.20.HF_tml <- read.csv("../data/external/sra_thml_14C_stoner/smooth_GRwf MOM_RPO.csv")
HF_tml.df <- cbind(rbind(ANwf.20.HF_tml, GRwf.20.HF_tml), 
                   site = c(rep("ANwf", nrow(ANwf.20.HF_tml)), rep("GRwf", nrow(GRwf.20.HF_tml))))
HF_tml.df$PM <- substr(HF_tml.df$site, 1, 2)

# plot
ggplot(HF_tml.df, aes(temp, CO2_scaled, color = PM)) +
  # geom_vline(xintercept = 250, color = "red", linetype = "dashed") +
  # geom_vline(xintercept = 370, color = "red", linetype = "dashed") +
  # geom_vline(xintercept = 370, color = "red", linetype = "dashed") +
  # geom_vline(xintercept = 500, color = "red", linetype = "dashed") +
  geom_line() +
  scale_color_manual(values = c("AN" = andesite,
                                "GR" = granite)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
